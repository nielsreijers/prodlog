#!/usr/bin/env python3
import sys
import os
import pty
import tty
import termios
import datetime
import socket
from pathlib import Path
import select
import subprocess
import argparse
import time
import json
import base64

PRODLOG_CMD_PREFIX = "\x1A(dd0d3038-1d43-11f0-9761-022486cd4c38) PRODLOG:"
CMD_IS_INACTIVE = "IS CURRENTLY INACTIVE"
CMD_ARE_YOU_RUNNING = "PRODLOG, ARE YOU RUNNING?"
CMD_START_CAPTURE = "START CAPTURE"
CMD_STOP_CAPTURE = "STOP CAPTURE"
REPLY_YES_PRODLOG_IS_RUNNING = "PRODLOG IS RUNNING"

def main():
    parser = argparse.ArgumentParser(description='Record shell output')
    parser.add_argument('command', nargs='?', choices=['run'], help='Command to execute')
    parser.add_argument('args', nargs=argparse.REMAINDER, help='Command line arguments')

    args = parser.parse_args()

    if args.command is None:
        parser.print_help()
        send_command(CMD_IS_INACTIVE)
        sys.exit(1)
    elif args.command == 'run':
        run_command(args.args)

def send_command(cmd, *args):
    encoded_args = [base64.b64encode(arg.encode()).decode() + ';' for arg in args]
    print(f"\n{PRODLOG_CMD_PREFIX}{cmd};{''.join(encoded_args)}")


def run_command(command):
    try:
        hostname = socket.gethostname()
        cwd = os.getcwd()
        cmd_str = ' '.join(command)

        # Check if prodlog is running
        send_command(CMD_ARE_YOU_RUNNING)

        # Wait up to 1 second for response
        rlist, _, _ = select.select([sys.stdin], [], [], 1.0)
        if not rlist:
            print("Error: prodlog is not running. Please start it first with 'prodlog record'")
            sys.exit(1)

        response = sys.stdin.readline().strip()
        if response != REPLY_YES_PRODLOG_IS_RUNNING:
            print("Error: unexpected response from prodlog")
            sys.exit(1)

        # Print start marker with metadata
        send_command(CMD_START_CAPTURE, hostname, cwd, cmd_str)

        # Execute command in a PTY
        master_fd, slave_fd = pty.openpty()
        process = subprocess.Popen(command,
                                 stdin=slave_fd,
                                 stdout=slave_fd,
                                 stderr=slave_fd,
                                 preexec_fn=os.setsid)
        os.close(slave_fd)

        # Save terminal settings
        old_settings = termios.tcgetattr(sys.stdin)
        try:
            # Set raw mode
            tty.setraw(sys.stdin)

            while process.poll() is None:  # Only run while process is alive
                rfds = [sys.stdin, master_fd]
                reads, _, _ = select.select(rfds, [], [], 0.1)  # Add timeout

                for fd in reads:
                    if fd == sys.stdin:
                        # Forward input to process
                        data = os.read(sys.stdin.fileno(), 1024)
                        try:
                            os.write(master_fd, data)
                        except OSError:
                            break  # Process probably died
                    else:
                        # Forward output to terminal
                        try:
                            data = os.read(master_fd, 1024)
                            if data:
                                sys.stdout.buffer.write(data)
                                sys.stdout.buffer.flush()
                        except OSError:
                            break  # Process probably died

        finally:
            # Restore terminal settings
            termios.tcsetattr(sys.stdin, termios.TCSAFLUSH, old_settings)
            try:
                os.close(master_fd)
            except OSError:
                pass

        # Print stop marker
        send_command(CMD_STOP_CAPTURE)

    except Exception as e:
        print(f"Error in run_command: {str(e)}", file=sys.stderr)
        import traceback
        traceback.print_exc(file=sys.stderr)
        sys.exit(1)

if __name__ == "__main__":
    main()