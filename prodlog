#!/usr/bin/env python3
import sys
import os
import pty
import tty
import termios
import datetime
import socket
from pathlib import Path

def show_usage():
    print("Usage: prodlog record")
    print("       Starts a new shell session and records all output to ~/.prodlog/output.log")
    print("Usage: prodlog run <command> [args...]")
    print("       Runs the specified command and records its output")
    sys.exit(1)

def main():
    try:
        if len(sys.argv) < 2:
            show_usage()

        if sys.argv[1] == "record":
            if len(sys.argv) != 2:
                show_usage()
            print("Starting record_shell...", file=sys.stderr)
            record_shell()
        elif sys.argv[1] == "run":
            if len(sys.argv) < 3:
                show_usage()
            print("Starting run_command...", file=sys.stderr)
            run_command(sys.argv[2:])
        else:
            show_usage()
    except Exception as e:
        print(f"Error in main: {str(e)}", file=sys.stderr)
        import traceback
        traceback.print_exc(file=sys.stderr)
        sys.exit(1)

def run_command(command):
    try:
        # Record start time
        start_time = datetime.datetime.now()
        hostname = socket.gethostname()
        cmd_str = ' '.join(command)
        
        header = f"""##### PRODLOG HEADER ===============================================================================
##### PRODLOG HEADER | Host: {hostname}
##### PRODLOG HEADER | Start: {start_time.isoformat()}
##### PRODLOG HEADER ===============================================================================
##### PRODLOG HEADER | Command: {cmd_str}
##### PRODLOG HEADER ==============================================================================="""

        # Print warning that will be hidden when running under record
        print("##### WARNING PRODLOG RECORD IS NOT RUNNING SO THIS IS NOT BEING RECORDED #####")

        # Print start marker and header
        print("\n##### PRODLOG START CAPTURE #####")
        sys.stdout.write(header + '\n')
        sys.stdout.flush()

        # Execute command and output to terminal
        try:
            process = os.popen(' '.join(command))
            output = process.read()
            sys.stdout.write(output)
            sys.stdout.flush()
        except Exception as e:
            print(f"Command execution error: {str(e)}\n", file=sys.stderr)
            raise

        # Record end time and calculate duration
        end_time = datetime.datetime.now()
        duration_ms = (end_time - start_time).total_seconds() * 1000

        footer = f"""##### PRODLOG FOOTER ===============================================================================
##### PRODLOG FOOTER | End: {end_time.isoformat()}
##### PRODLOG FOOTER | Duration: {duration_ms:.2f}ms
##### PRODLOG FOOTER ==============================================================================="""

        # Print footer and stop marker
        sys.stdout.write(footer + '\n')
        sys.stdout.flush()
        print("##### PRODLOG STOP CAPTURE #####")
        print("##### WARNING PRODLOG RECORD IS NOT RUNNING SO THIS IS NOT BEING RECORDED #####")
    
    except Exception as e:
        print(f"Error in run_command: {str(e)}", file=sys.stderr)
        import traceback
        traceback.print_exc(file=sys.stderr)
        sys.exit(1)

def record_shell():
    # Configure log file location
    log_file = Path.home() / ".prodlog" / "output.log"
    log_file.parent.mkdir(exist_ok=True)

    # Add this function to handle window size changes
    def set_window_size(fd):
        # Get the window size of our terminal
        import struct, fcntl, termios
        size = struct.pack('HHHH', 0, 0, 0, 0)
        size = fcntl.ioctl(sys.stdin.fileno(), termios.TIOCGWINSZ, size)
        rows, cols, _, _ = struct.unpack('HHHH', size)
        # Set the child terminal to the same size
        fcntl.ioctl(fd, termios.TIOCSWINSZ, struct.pack('HHHH', rows, cols, 0, 0))

    def read(fd):
        # Add buffer as instance variable if not present
        if not hasattr(read, 'buffer'):
            read.buffer = ''
        if not hasattr(read, 'capturing'):
            read.capturing = False
        if not hasattr(read, 'alternate_screen'):
            read.alternate_screen = False
        
        # Read raw data
        data = os.read(fd, 1024)
        decoded = data.decode(errors='replace')
        
        # Check for alternate screen mode sequences
        if '\x1b[?1049h' in decoded:  # Enter alternate screen
            read.alternate_screen = True
            return data  # Pass through raw data
        elif '\x1b[?1049l' in decoded:  # Exit alternate screen
            read.alternate_screen = False
            return data  # Pass through raw data
        elif read.alternate_screen:
            return data  # Pass through raw data while in alternate screen
        
        # Add to buffer
        read.buffer += decoded
        
        # Process complete lines
        lines = read.buffer.split('\n')
        # Keep the last potentially partial line in the buffer
        read.buffer = lines[-1]
        
        # Prepare modified data for terminal display
        modified_data = ''
        
        # Process all complete lines
        for line in lines[:-1]:
            # Replace warning with "being recorded" message
            if "##### WARNING PRODLOG RECORD IS NOT RUNNING SO THIS IS NOT BEING RECORDED #####" in line:
                modified_data += "##### OUTPUT RECORDED BY PRODLOG #####\n"
                continue
            
            # Handle header and footer lines
            if line.startswith("##### PRODLOG HEADER ") or line.startswith("##### PRODLOG FOOTER "):
                if read.capturing:
                    # Write to log file without the marker prefix
                    with open(log_file, 'a') as f:
                        f.write(line[20:] + '\n')  # Skip "##### PRODLOG HEADER " or "##### PRODLOG FOOTER "
                continue
            
            if "##### PRODLOG START CAPTURE #####" in line:
                read.capturing = True
                continue
            
            if "##### PRODLOG STOP CAPTURE #####" in line:
                read.capturing = False
                continue
            
            # Output regular lines to terminal and log
            modified_data += line + '\n'
            
            # Only write regular lines to log file if we're capturing
            if read.capturing:
                with open(log_file, 'a') as f:
                    f.write(line + '\n')
                    f.flush()
        
        # Handle any remaining partial line (likely a prompt)
        if lines[-1]:
            if decoded.endswith('\n'):
                # If it's a complete line, no prefix needed
                modified_data += lines[-1] + '\n'
            else:
                # If it's a prompt (no newline), just output it directly
                modified_data += lines[-1]
        
        # Return the modified data for terminal display
        return modified_data.encode()
    
    # Initialize capturing state
    read.capturing = False

    # Save original terminal settings
    old_settings = termios.tcgetattr(sys.stdin)
    
    try:
        # Create pseudo-terminal
        pid, fd = pty.fork()
        
        if pid == 0:  # Child process
            # Execute user's shell
            shell = os.environ.get('SHELL', '/bin/bash')
            os.execv(shell, [shell])
        else:  # Parent process
            # Set initial window size
            set_window_size(fd)
            
            # Set raw mode
            tty.setraw(sys.stdin.fileno())
            
            while True:
                try:
                    # Watch both original input and child's output
                    rfds = [sys.stdin, fd]
                    reads, _, _ = select.select(rfds, [], [])

                    for read_fd in reads:
                        if read_fd == sys.stdin:
                            # Forward input to child
                            data = os.read(sys.stdin.fileno(), 1024)
                            if data == b'\x1c':  # SIGWINCH - window size changed
                                set_window_size(fd)
                            os.write(fd, data)
                        else:
                            # Forward child's output to stdout
                            try:
                                data = read(fd)
                                if not data:
                                    raise EOFError
                                os.write(sys.stdout.fileno(), data)
                            except EOFError:
                                # Child process ended
                                raise

                except (EOFError, OSError):
                    break

    except Exception as e:
        if read.capturing:
            with open(log_file, 'a') as f:
                f.write(f"\nError: {str(e)}\n")
    finally:
        # Restore original terminal settings
        termios.tcsetattr(sys.stdin, termios.TCSAFLUSH, old_settings)

if __name__ == "__main__":
    import select  # Import here to avoid potential circular imports
    main()