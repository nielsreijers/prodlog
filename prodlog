#!/usr/bin/env python3
import sys
import os
import pty
import tty
import termios
import datetime
import socket
from pathlib import Path

def show_usage():
    print("Usage: prodlog record")
    print("       Starts a new shell session and records all output to ~/.prodlog/output.log")
    print("Usage: prodlog run <command> [args...]")
    print("       Runs the specified command and records its output")
    sys.exit(1)

def main():
    if len(sys.argv) < 2:
        show_usage()

    if sys.argv[1] == "record":
        if len(sys.argv) != 2:
            show_usage()
        record_shell()
    elif sys.argv[1] == "run":
        if len(sys.argv) < 3:
            show_usage()
        run_command(sys.argv[2:])
    else:
        show_usage()

def run_command(command):
    # Record start time
    start_time = datetime.datetime.now()
    hostname = socket.gethostname()
    cmd_str = ' '.join(command)
    
    header = f"""
╔══════════════════════════════════════════════════════════════════════════════
║ Host: {hostname}
║ Start: {start_time.isoformat()}
╠══════════════════════════════════════════════════════════════════════════════
║ Command: {cmd_str}
╠══════════════════════════════════════════════════════════════════════════════
"""

    # Print warning that will be hidden when running under record
    print("##### WARNING PRODLOG RECORD IS NOT RUNNING SO THIS IS NOT BEING RECORDED #####")

    # Print start marker (hidden in log but triggers capture)
    print("\n##### PRODLOG START CAPTURE #####")
    
    # Write formatted header
    print(header, end='')

    # Execute command and output to terminal
    try:
        process = os.popen(' '.join(command))
        output = process.read()
        print(output, end='')
    except Exception as e:
        print(f"║ Error: {str(e)}\n", end='')

    # Record end time and calculate duration
    end_time = datetime.datetime.now()
    duration_ms = (end_time - start_time).total_seconds() * 1000

    footer = f"""
╠══════════════════════════════════════════════════════════════════════════════
║ End: {end_time.isoformat()}
║ Duration: {duration_ms:.2f}ms
╚══════════════════════════════════════════════════════════════════════════════
"""

    # Write formatted footer
    print(footer, end='')
    
    # Print stop marker (hidden in log but triggers capture)
    print("##### PRODLOG STOP CAPTURE #####")
    print("##### WARNING PRODLOG RECORD IS NOT RUNNING SO THIS IS NOT BEING RECORDED #####")

def record_shell():
    # Configure log file location
    log_file = Path.home() / ".prodlog" / "output.log"
    log_file.parent.mkdir(exist_ok=True)

    # Add this function to handle window size changes
    def set_window_size(fd):
        # Get the window size of our terminal
        import struct, fcntl, termios
        size = struct.pack('HHHH', 0, 0, 0, 0)
        size = fcntl.ioctl(sys.stdin.fileno(), termios.TIOCGWINSZ, size)
        rows, cols, _, _ = struct.unpack('HHHH', size)
        # Set the child terminal to the same size
        fcntl.ioctl(fd, termios.TIOCSWINSZ, struct.pack('HHHH', rows, cols, 0, 0))

    def read(fd):
        # Add buffer as instance variable if not present
        if not hasattr(read, 'buffer'):
            read.buffer = ''
        if not hasattr(read, 'capturing'):
            read.capturing = False
        if not hasattr(read, 'alternate_screen'):
            read.alternate_screen = False
        
        # Read raw data
        data = os.read(fd, 1024)
        decoded = data.decode(errors='replace')
        
        # Check for alternate screen mode sequences
        if '\x1b[?1049h' in decoded:  # Enter alternate screen
            read.alternate_screen = True
            return data  # Pass through raw data
        elif '\x1b[?1049l' in decoded:  # Exit alternate screen
            read.alternate_screen = False
            return data  # Pass through raw data
        elif read.alternate_screen:
            return data  # Pass through raw data while in alternate screen
        
        # Add to buffer
        read.buffer += decoded
        
        # Process complete lines
        lines = read.buffer.split('\n')
        # Keep the last potentially partial line in the buffer
        read.buffer = lines[-1]
        
        # Prepare modified data for terminal display
        modified_data = ''
        
        # Process all complete lines
        for line in lines[:-1]:
            # Skip warning and start/stop markers
            if "##### WARNING PRODLOG RECORD IS NOT RUNNING SO THIS IS NOT BEING RECORDED #####" in line:
                continue
            if "##### PRODLOG START CAPTURE #####" in line:
                read.capturing = True
                continue
            if "##### PRODLOG STOP CAPTURE #####" in line:
                read.capturing = False
                continue
            
            # Just output the line without prefix
            modified_data += line + '\n'
            
            # Only write to log file if we're capturing
            if read.capturing:
                with open(log_file, 'a') as f:
                    f.write(line + '\n')
                    f.flush()
        
        # Handle any remaining partial line (likely a prompt)
        if lines[-1]:
            if decoded.endswith('\n'):
                # If it's a complete line, no prefix needed
                modified_data += lines[-1] + '\n'
            else:
                # If it's a prompt (no newline), just output it directly
                modified_data += lines[-1]
        
        # Return the modified data for terminal display
        return modified_data.encode()
    
    # Initialize capturing state
    read.capturing = False

    # Save original terminal settings
    old_settings = termios.tcgetattr(sys.stdin)
    
    try:
        # Create pseudo-terminal
        pid, fd = pty.fork()
        
        if pid == 0:  # Child process
            # Execute user's shell
            shell = os.environ.get('SHELL', '/bin/bash')
            os.execv(shell, [shell])
        else:  # Parent process
            # Set initial window size
            set_window_size(fd)
            
            # Set raw mode
            tty.setraw(sys.stdin.fileno())
            
            while True:
                try:
                    # Watch both original input and child's output
                    rfds = [sys.stdin, fd]
                    reads, _, _ = select.select(rfds, [], [])

                    for read_fd in reads:
                        if read_fd == sys.stdin:
                            # Forward input to child
                            data = os.read(sys.stdin.fileno(), 1024)
                            if data == b'\x1c':  # SIGWINCH - window size changed
                                set_window_size(fd)
                            os.write(fd, data)
                        else:
                            # Forward child's output to stdout
                            try:
                                data = read(fd)
                                if not data:
                                    raise EOFError
                                os.write(sys.stdout.fileno(), data)
                            except EOFError:
                                # Child process ended
                                raise

                except (EOFError, OSError):
                    break

    except Exception as e:
        if read.capturing:
            with open(log_file, 'a') as f:
                f.write(f"\nError: {str(e)}\n")
    finally:
        # Restore original terminal settings
        termios.tcsetattr(sys.stdin, termios.TCSAFLUSH, old_settings)

if __name__ == "__main__":
    import select  # Import here to avoid potential circular imports
    main()