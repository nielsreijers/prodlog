#!/usr/bin/env python3
import sys
import os
import pty
import tty
import termios
import datetime
import socket
from pathlib import Path

def show_usage():
    print("Usage: prodlog record")
    print("       Starts a new shell session and records all output to ~/.prodlog/output.log")
    print("Usage: prodlog run <command> [args...]")
    print("       Runs the specified command and records its output")
    sys.exit(1)

def main():
    if len(sys.argv) < 2:
        show_usage()

    if sys.argv[1] == "record":
        if len(sys.argv) != 2:
            show_usage()
        record_shell()
    elif sys.argv[1] == "run":
        if len(sys.argv) < 3:
            show_usage()
        run_command(sys.argv[2:])
    else:
        show_usage()

def run_command(command):
    # Print start marker
    print("\n##### PRODLOG START CAPTURE #####")

    # Create header
    hostname = socket.gethostname()
    timestamp = datetime.datetime.now().isoformat()
    cmd_str = ' '.join(command)
    header = f"\n=== Host: {hostname} ===\n=== Time: {timestamp} ===\n=== Command: {cmd_str} ===\n"

    # Write header to terminal
    print(header, end='')

    # Execute command and output to terminal
    try:
        process = os.popen(' '.join(command))
        output = process.read()
        print(output, end='')
    except Exception as e:
        print(f"\nError: {str(e)}\n", end='')

    # Print stop marker
    print("\n##### PRODLOG STOP CAPTURE #####")

def record_shell():
    # Configure log file location
    log_file = Path.home() / ".prodlog" / "output.log"
    log_file.parent.mkdir(exist_ok=True)

    def read(fd):
        # Add buffer as instance variable if not present
        if not hasattr(read, 'buffer'):
            read.buffer = ''
        if not hasattr(read, 'capturing'):
            read.capturing = False
        
        # Read raw data
        data = os.read(fd, 1024)
        decoded = data.decode(errors='replace')
        
        # Add to buffer
        read.buffer += decoded
        
        # Process complete lines
        lines = read.buffer.split('\n')
        # Keep the last potentially partial line in the buffer
        read.buffer = lines[-1]
        # Process all complete lines
        for line in lines[:-1]:
            # Check for start/stop markers
            if "##### PRODLOG START CAPTURE #####" in line:
                read.capturing = True
                with open(log_file, 'a') as f:
                    f.write(line + '\n')
                    f.flush()
                continue
            
            if "##### PRODLOG STOP CAPTURE #####" in line:
                # Write the stop marker before turning off capturing
                with open(log_file, 'a') as f:
                    f.write(line + '\n')
                    f.flush()
                read.capturing = False
                continue
            
            # Only write to log file if we're capturing
            if read.capturing:
                with open(log_file, 'a') as f:
                    f.write(line + '\n')
                    f.flush()
        
        return data
    
    # Initialize capturing state
    read.capturing = False

    # Save original terminal settings
    old_settings = termios.tcgetattr(sys.stdin)
    
    try:
        # Create pseudo-terminal
        pid, fd = pty.fork()
        
        if pid == 0:  # Child process
            # Execute user's shell
            shell = os.environ.get('SHELL', '/bin/bash')
            os.execv(shell, [shell])
        else:  # Parent process
            # Set raw mode
            tty.setraw(sys.stdin.fileno())
            
            while True:
                try:
                    # Watch both original input and child's output
                    rfds = [sys.stdin, fd]
                    reads, _, _ = select.select(rfds, [], [])

                    for read_fd in reads:
                        if read_fd == sys.stdin:
                            # Forward input to child
                            data = os.read(sys.stdin.fileno(), 1024)
                            os.write(fd, data)
                        else:
                            # Forward child's output to stdout
                            try:
                                data = read(fd)
                                if not data:
                                    raise EOFError
                                os.write(sys.stdout.fileno(), data)
                            except EOFError:
                                # Child process ended
                                raise

                except (EOFError, OSError):
                    break

    except Exception as e:
        if read.capturing:
            with open(log_file, 'a') as f:
                f.write(f"\nError: {str(e)}\n")
    finally:
        # Restore original terminal settings
        termios.tcsetattr(sys.stdin, termios.TCSAFLUSH, old_settings)

if __name__ == "__main__":
    import select  # Import here to avoid potential circular imports
    main()